\chapter{Conclusion and Future}
\label{ch:Future}
In this chapter, we summarize the contributions and results of this thesis and provide some insight on some possibilities for new features that follow along the path set by this thesis. 

\section{Conclusion}
In this thesis, we made several contribution to the goal of advancing the CRI. The UI has been updated to direct the users focus in addition to speeding up tasks performed by a user. We also reduced the cognitive load presented by the UI itself. An objective verification of this using multiple usability metrics like a User Study and Clickstream analysis is still missing, but most changes have clear benefits. We further strengthened the connection between the abstract representation and the source code with the introduction of Source Code Tooltips. The evaluation showed the potential information gain added by this feature. Along with its simplicity and accessibility, this makes Source Code Tooltips a valuable addition to the CRI.
However, even though many improvements have been made to cope with resource demanding applications that contain, for example, rapidly updated observables, there is still some development effort required to remove the current limitations as seen in the RxJS test application \emph{mario}. We also proposed several approaches to better support excessively created observables.
One of these approaches is required to increase the CRI's robustness when handling any arbitrary application. However, as we have explained, the extension is still usable to some degree with most applications that excessively create observable except in very severe cases.
As part of this thesis, we also improved extensibility and maintainability of the extensions source code. However, the evaluation of the test applications and features of the CRI, including features introduced by this thesis, has shown that some of these features still need to be improved with further development.

Nonetheless, the Chrome Reactive Inspector supports many features that help to cope with issues encountered by reactive debuggers in general. Including some that are currently not present in its main competitor RxFiddle.

\section{Future}
In this section we discuss targets for future development that were not implemented as part of this thesis. We focus on possible additions to the CRI which would further increase the range of supported applications. As TypeScript and ECMA2015 compliant JavaScript (ES6) have become very popular as they overcome some limitations of ECMA5 compliant JavaScript (ES5), supporting these technologies would broaden the range of application the CRI supports by far. However the used Jalangi Demo library is not able to handle either. Especially due to this reason, it would be beneficial to replace Jalangi with another JS code analysis library that works in-browser by design. Although it would also be possible to add a dedicated second library explicitly to instrument and analyze TypeScript and ES6 to the CRI because it is unlikely that there is a tool that is able to handle all three technologies. Many Web applications that use ES6 in their development actually \emph{transpile} it to ES5 because ES6 is not fully supported by all browsers yet. This means, that the CRI could be used on the \emph{transpiled} JS code, but it renders the Source Code Tooltips useless since the code shown is not the one the user is working with.

Another advancement for the CRI would be supporting the loading of scripts from within other scripts. This has become a usual practice\footnote{RequireJS is ranked place 14 in the top used JavaScript libraries and functions according to https://trends.builtwith.com/javascript/RequireJS - Week beginning Jan 01nd 2018 queried on \date{2018-01-03}} for many developers, since its introduction, and is referred to as module loading. There are several popular libraries that include module loading functionality. These include NodeJS \cite{NodeJS}, requireJS \cite{RequireJS}, as well as, the \emph{import} keyword used in ES6 and TypeScript. Since the CRI scans an inspected page for HTML \emph{script} tags to determine if the recording should run, any script using a module loader to load scripts that use RxJS or BaconJS cannot be recorded properly. Scripts loaded by module loaders are also excluded from the instrumentation process. To create the dependency graph the CRI records internal processes of RxJS or BaconJS. For this reason, the CRI needs access to the \emph{Rx} or \emph{Bacon} object used in the inspected applications scripts. To enable the use of the CRI with applications using module loaders, the tool would need to intercept calls to the respective module loader and load the files itself before submitting them to the application. This way, the loaded scripts could also be replaced with an instrumented version. The breach of the \emph{isolated world} Chrome extension content scripts normally run in as explained in section \ref{sec:CRISpecials}, enables the developer to have total access to the pages JS. Therefore, to solve the problem of module loaders, the developer could overwrite the respective loading function or keyword and provide a custom implementation that submits the scripts to the CRI before actually loading them.
	
To further improve the CRI's ability to handle applications using rapidly updated observables, the current node exclusion feature should be extended. Currently, the feature only allows the user to exclude nodes by Id from the extension Option page. This is very cumbersome to do for many nodes as the user repeatedly needs to leave the context of the CRI DevTools panel. As discussed in section \ref{sec:additonPerformance} usually more than one node needs to be excluded. In addition excluding a node completely may distort the dependency graph due to missing edges. A more sophisticated approach would be to only exclude value updates beyond the first for a node because this would keep the dependency graph complete. It would also ease the use of the exclusion feature if the user would be able to exclude nodes by a direct interaction with that node, for example, via a right click and a context menu. To improve usability if a chain of observables each are rapidly updated it would also be helpful to provide an option to exclude all dependents or ancestors in the dependency chain from the recording as well.
As the exclusion of a node is always specific to a single inspected application, providing persistent customization for a single application as discussed in section \ref{sec:DynamicallyCreated} would also improve user experience.

Since the presented solutions for handling excessively created observables in section \ref{sec:DynamicallyCreated} were not implemented as part of this thesis, they are also a target for further development so as to increase the range of applications the CRI supports.
 	
