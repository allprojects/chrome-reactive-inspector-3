\chapter{Conclusion and Future}
\label{ch:Future}

% Conclusion:
% Advanced the CRI by:

% - The UI has been updated to direct the users focus and speed up or reduce cognitive load for some user tasks. An objective verification using multiple usability metrics like a User Study and Clickstream analysis is still missing, but most changes have a clearly explained benefit.
% - To strengthen links* between abstract representation and acutal code, source code previews* have been introduced. The evaluation showed the potential for this feature and in addition with the ease of access, this makes it a valuable additon to CRI.
% - Even though many improvements have been made to cope with large*(always use the same terminology) graphs/histories/applications like performance improvements, it does not cover everything.
% - CRI has a way to go before being able to properly support excessively created observables.
% This and some other features are required to increase CRI's robustness when handling any arbitrary application, however, it is still useable to some degree for most of these applications except for very severe cases.
% improved extensibility and maintainability
% The evaluation showed that some of the features of CRI still need some improvements in special cases.

% - CRI supports many additional features that help to cope with some of the issues encountered by reactive debuggers that are currently not present in RxFiddle.

% Future:

% To extend the range of applications CRI can be used with, CRI needs TypeScript and ECMA2015 compliant JavaSCript support. However the used Jalangi Demo library is not able to handle either. Due to this reason and others it would be beneficial to replace Jalangi with another JS code analysis that works in-browser by design, although it is also possible to add a dedicated a second library explicitly for TypeScript and ECMA2015 compliant JavaScript because it is unlikely that there is a tool that is able to handle both. Many Web applications that use ECMA6 in their development actually transpile it to ECMA5 because ECMA2015 is not fully supported by each broser yet. This means, that CRI could be used on the transpiled JS code, but it renders the Source Code Tooltips useless since the code shown is not the one the user is editing.

% Support for loading of JS scripts from within other scripts. This has become a usual practice for many developers since the introduction of module loaders. There are several popular libraries that inlcude module loading functionallity. These inlcude NodeJS, requireJS, as well as, the \emph{import} keyword used in ECMA2015 compliant JavaScript and TypeScript. Since CRI scans an inspected page for HTML \emph{script} tags to determine if the recording should run, any script using a module loader to load scripts that use RxJS or BaconJS cannot be recorded properly. Scripts loaded by module loaders are also excluded from the instrumentation process. To create the Dependency Graph, CRI records internal processes of RxJS or BaconJS. For this reason, CRI needs access to the Rx or Bacon object used in the inspected applications scripts. To enable the use of CRI with applications using module loaders, the tool would need to intercept calls to the module loader and load the files itself before submitting them to the application. This way, the loaded scripts could also be replaced with an instrumented version. 
%- the breach of the isolated world of chrome context scripts enables the developer to have a total access to the pages javascript 	which can be used to solve the problem of "import" statements. The developer could overwrite the import/require/.. comands of each known framework and provide a custom function that does the loading in additional
	
% Additional features to help the user support CRI with applications using rapdily updates observables.
	% Excluding a node -> limitation:
	% may need to cover many nodes before the ui values are mapped to readable values -> ignore all ancestors option 
	% currently nodes can be excluded via Id in the options page, but this is to cumbersome since the user has to leave the current context, they are specific to one application and should not be in general options.
	%- should be able to ignore nodes via r-click on node, even with an option to exclude all dependents/dependencies - that did not work because time. Ignoring a node completely will sometimes break the dependency graph. Excluded nodes should be created and only value updates beyond the first should be ignored.

% The features discussed in Excessivel Created Observables section that were not possible to implement as part of this thesis.
 	
