\chapter{Contribution}
In this chapter ..

In the following sections "Observable" is used to denote an actual RxJS Observable and also as a placeholder for any Reactive entity from RxJS or BaconJS in lack of a better term.

\section{Advancing the User Interface}
The User Interface (UI) is an important part of every application. A good UI helps the user focus on the task at hand by displaying the necessary information required for that task. For a Website this task may simply be to find gather information about the subject of the Website itself. An IDE usually provides many tools the user can use and reduce the manual work of the user by automating some steps of the development process. There are many factors that need to be taken into account when developing a new UI or changing an existing one. A UI should normally be designed to match the special use-cases the application was designed for while also keeping some familiar elements to guide the user. The main reason to keep a somewhat familiar look or have a certain part of the UI match what the user expects and knows from other applications in his domain, is that the user already knowns how to interact with familiar elements and does not have to learn how to use them from scratch. It is also important to consider some of the characteristics of human cognition. To explain them all in detail is beyond the scope of this thesis. To solve this type of problems if a main target of the Interactive Graphics Systems Group (GRIS) at TU-Darmstadt and many other groups world wide are working in this field. In the following paragraph we examine the changes to the UI of CRI we implemented in this thesis and the reasoning behind these changes.
  
\textbf{Reducing the cognitive load on the user}
The main goal of the changes to the UI we implemented in this thesis is to reduce the cognitive load on the user. If the user has to concentrate and search for information they need to achieve their task and not having them presented in an easy to find and understand manor, half of his attention is already occupied. It can not be used to work on the task and achieve their actual goal.

The first change we introduced to reduce the cognitive load on the user is to move some input elements to a menu that is displayed at the top of the CRI's UI. Nearly every desktop application and many Websites (e.g. http://reactivex.io/rxjs/, Windows File Explorer, Eclipse, Microsoft Paint, Adobe PDF Reader and many more) use a menu at the top of the UI. This adds structure and also removes many buttons from the normal working space which can then be used to display more relevant information. The user knows that the buttons are in the menu and searches though it on demand. The buttons hidden in the menu bar do not require space or attention by the user at other times, except for the space required by the menu itself. We examined our own usage frequency, how often we use a certain input element, and estimated the tasks that include the input element to determine which elements should be part of the main UI and which should be hidden in a menu (or closeable panel for inputs other than buttons). We found that we rarely used the \emph{Reset}, \emph{Download} and \emph{Pause/Resume} buttons. The latter was used most among them and since CRI does not actually have loads of buttons yet, we decided to place it directly in the menu bar instead of moving it into the sub menu used for the other rarely used buttons. The \emph{Pause/Resume} button is also the only one of those buttons used in a normal workflow, i.e. in the special case of working with Rapidly updated Observables (see section \ref{sec:RapidlyUpdatedObservables}) it is used regularly to counter performance issues or focus on a specific part of the execution.  %TODO: maybe add screenshot of menu
The other buttons of the UI are part of a specific feature of CRI and can not be moved away from other elements that belong to the features. These features from left top to bottom right are the Instrumented Files list, History Queries and the navigation through the results, Reactive Breakpoints, Search, History Navigation and the Dependency Graph. The Dependency Graph and History Navigation are closely tied together and represent the main part of CRI. They are the working area where the focus of the UI should be. The other features are complementary to them support the user ins examining their content. Although CRI can be used effectively without History Queries and Reactive Breakpoints they can help the user in almost any task. Reactive Breakpoints may even be mandatory to discover some issues with an application that otherwise could not be detected without a much greater effort (similar to normal Breakpoints in traditional IDEs). While the Dependency Graph with its History is just another way to provide an abstract representation of Observables and Dependencies then the Marble Diagrams used in RxFiddle, Reactive Breakpoints are currently exclusive to CRI. In conclusion, History Queries and Reactive Breakpoints should be a permanent part of the UI, therefore we decided to keep them where they were positioned in CRI2 - above the History Navigation. The Search feature is not as important in most tasks. The highlighting of a specific node, its Dependencies or Dependents is only useful for applications with large Dependency Graphs. Small graphs can easily be searched for the required information manually with one look. Therefore the Search feature could be moved to a closeable panel that is only opened on demand. The search implemented in most IDEs opens when the user presses CTRL F or clicks the search button in the menu. The reason we did not move the feature to a closeable panel yet is simply that the area of the UI where the History Query and Reactive Breakpoints input elements are placed provides enough space (with standard screen resolutions sizes for desktop computers) to keep the Search there as well. With the current UI the space would otherwise be empty. However as soon as these parts of the UI change or another feature is introduced, the Search should be moved to a closeable panel. The remaining feature is the Instrumented Files list. It is used as a scoping feature to select which files should be instrumented. For small to medium sized applications the list of files will normally include all relevant JS files and will not be changed at all. It is therefore reasonable to move it from the main UI to free the space that could then be used to increase the size of the Dependency Graph canvas. After examining the outcome of this change we found however, that in case the user switches to another application that requires other files to be instrumented or forgot to include a JS file in the list, it can be really difficult to detect the reason why the Dependency Graph is not showing the expected result. If the Instrument Files list is moved from the main UI, the user may loose track of the fact that not all JS files are automatically instrumented or, if they decided to instrument only a subset of JS files as a filtering measure, that the >filter< is still in place. It is also easier for new users to comprehend the need to select files for instrumentation if the list is part of the main UI. This could be mitigated by adding a dialog informing the user at the first start of CRI, but for this reason in addition to the reasons mentioned above we decided the benefits outweigh the downside of a small part of the UI being occupied by a rarely changed input. Therefore we kept the Instrument Files list at the top of the UI and also added a red border around the text input as an validation error in case the list is empty to help make new users aware of the missing input.

To further decrease the cognitive load when working with CRI, we removed any text from nodes and their tooltips that do not carry any value. The less text there is on the UI, the less as user has to read to find the information that they require. This is most significant for the \emph{Method} field in the tooltips since most Observables do not correspond to a method and the field therefore is empty for most nodes. The \emph{Value} field is usually set, but if there is no value, there is no need to keep the label for the field. The same information is available to the user if the label for \emph{Value} is simply omitted in that case.
It is however important to display values that explicitly denote an \emph{empty} value like \emph{undefined}, \emph{null}, or -1 (for a value that carries positive numbers if it is set). The \emph{Name} field is also not set for every node. Figure \ref{fig:Nodes} shows an example of nodes from CRI2 with all field as well as nodes from the current version.

\begin{figure}[!h]
	\centering
	\subfloat[CRI version 2.0]{\includegraphics[width=0.4\textwidth]{gfx/NodesCRI2.png}\label{fig:NodesCRI2}}
	\hfill
	\subfloat[CRI version 3.0]{\includegraphics[width=0.4\textwidth]{gfx/NodesCRI3.png}\label{fig:NodesCRI3}}
	\caption{A sample of nodes before and after the changes introduced by this thesis.}
	\label{fig:Nodes}
\end{figure}
%TODO: casing of \emph{Named} node and dependency
Another important aspect to consider is if to display a field on the node directly or in the tooltip. The same principle that applies to general elements of the UI applies here as well. Only values that are necessary to always have present without the need to open every tooltip should be displayed as part of the nodes. We evaluated for each field where it should be located regarding this criteria. The \emph{Name} is important to identify relevant nodes, including those depending or dependent on a \emph{Named} node. The \emph{Id} is required to add Reactive Breakpoints and to identify nodes without a name from one step to another in case the nodes are repositioned due to a new edge being added. The \emph{Value} is normally the property at which developers can see if the JS code of the application works as intended. E.g. an Observable is expected to have a specific value at some point in the execution. The developer can also observe a value passing along the chain of dependencies. For these reason the fields \emph{Name}, \emph{Id} and \emph{Value} should be always displayed, as long as they have a value, as part of the node.
The \emph{Type} should be hidden in the tooltip, because often what type of Observable the framework uses internally does not matter to the developer. E.g. in most scenarios for RxJS there is not difference between a FromEventObservable and a basic Observable. The information should however, be still present in the tooltip and not omitted completely, because some types of Observables do behave differently than others e.g. RxJS Subject vs Observable. The source code position labeled \emph{Source} is also just used in few special tasks. On example is the user wanting to find the source code corresponding to a node in the graph to modify that code or inspect it further. The \emph{Source} should therefore be displayed in the tooltip rather the nodes themselves. The field \emph{Number of Updates} was introduces by this thesis as a way to detect bottlenecks and help identify nodes that cause the generation of a huge amount of steps through excessive value updates in CRI. It is based on the Time Profiling feature of the Reactive Inspector \cite{ReactiveInspector}, but for now only provides the total number of updates on a node instead of detailed timing and value evaluation information. It is only useful for the purposes mentioned above and therefore should not be displayed on the nodes themselves.

An important cognitive task that a user has to do often while using CRI is to track changes between steps in the Dependency Graph History. To track these changes is necessary to understand how the graph is constructed or to track value updates traveling along a chain of dependent Observables. It is however not always trivial since the rendering engine \emph{D3.js} \cite{D3JS} used by CRI sometimes moves nodes and edges around to better fit the available space. To help the user with this task, the previous version of CRI already highlighted the nodes that were changed for each step in which a node was changed. We extended this feature to also highlight edges that were updated or added to further decrease the manual searching process. Another feature we added to the UI is a button that hides the tool section of the UI - everything except the menu, History Navigation and Dependency Graph - to allow the user to reduce distractions and free up additional space if they want to focus on the manual examination of the graph and its History. The button is located at the top right corner and has a small arrow icon instead of a text label to reduce its required space in the UI. The option to hide the tool section is especially useful when working with a small screen or a big Dependency Graph. Another button we added to the UI, as part of the menu, was a button to reload the inspected page and therefore the Dependency Graph as well. We discovered that reloading, was already part of the usual workflow by pressing CTRL F5 and decided to add a button that allows user to achieve this without being aware of the short cut. An example workflow in which reload would be used is to create a breakpoint for \emph{dependencyCreated} or \emph{nodeCreated}, and then reloading the application to actually hit the breakpoint.


	% - remove "error" color from normal workflow to decrease cognitive load on the used. Red is associated with errors, warnings and dangers e.g. in traffic especially with high contrast (green). The user should immediately be able to identify the change, but the changed node does not require the full attention over the whole time
		%, we therefore moved from using red with high contrast that may even be probelematic for color blind users to an equally destinguishable but less demanding color sheme using blue and orange with less contrast. To this purpose we chose a shade of blue and selected the colors for nodes, edges and highlightings from suggestions provided by a color sheme designer \cite{Paletton}. We chose to keep the text color black, because its the most used color for text and easy to read on most background colors. The nodes that do not correspond to a named variable were left with a white background to further reduce the coginitive load. The brain is trained to ignore empty spaces therefore making the text and named nodes appear more important.

	% - starting on a new application or different part of the application -> auto reload after instrumented files have changed. This does not reduce the cognitive load on the user but removes a redundant click on the reload button. It is not very usefull to change the instrumented files without restarting the recording and will most likely confuse the user if they forget to do it. 


% It is also an option to replace the different node styles currently used to show a node >state< that shows what level of details are present for a node, with styling based on the chararcteristics of an Observable like its type.
	
\section{Connecting abstract graph with JavaScript code}
	% goal: to porvide nodes without a name with additonal details that allows to put them into context. Connect the abstract representation with the code to allow developer to see the code responsible for an issue they detected - was possible before with line information, but very cumbersome to do for more than one node. The developer should be able to easily switch between source code inspection and dependency graph inspection, because not all issues can be found in either of them when used alone. E.g. there is an issue in a lambda function - the developer can not find this issue directly in the dependency graph, he can only see the result in node values that do not match the values expected with the original intention of the code. To fix the issue the dev has to switch to the code anyway so he already has to use both representations in tandem. 
	% The main difficutly to achieve this is ... and has to be considered when developing possible solutions. :
		% The JS code that is used during runtime is instrumented. Jalangi instrumented code is very hard to read as is shown in listing \ref{lst:Instrumented}. For example "J$.W" signals the analysis engine that a write operation is executed when the function is called. This makes it unfeasable to directly show it to the user. in addition it is an implementation detail of CRI and should not be disclosed. Additionally the code position retrieved from the Jalangi analysis corresponds to the position in the original source code without the instumentation.
		% The JS code that is used during runtime is dynamically loaded and therefore can not be navigated to out of the box with the Chrome DevTools navigation API. Although this is mitigated by adding "//# sourceURL=" and a custom url to the bottom of the scripts. Since this shows the Jalangi instrumented source code that is not useful for a normal user, we decided to tie this to a new option called "CRI Developer Mode" that can be enabled in the options page of CRI.
	
	\begin{lstlisting}[language=JavaScript, caption={Example of RxJS code.},label={lst:Instrumented}]
	$sonWallet = J$.W(593, '$sonWallet', J$.F(585, J$.I(typeof $ === 'undefined' ? $ = J$.R(569, '$', undefined, true, true) : $ = J$.R(569, '$', $, true, true)), false)(J$.T(577, '#wallet-son', 21, false)), J$.I(typeof $sonWallet === 'undefined' ? undefined : $sonWallet), true, true);
	$fatherWallet = J$.W(625, '$fatherWallet', J$.F(617, J$.I(typeof $ === 'undefined' ? $ = J$.R(601, '$', undefined, true, true) : $ = J$.R(601, '$', $, true, true)), false)(J$.T(609, '#wallet-father', 21, false)), J$.I(typeof $fatherWallet === 'undefined' ? undefined : $fatherWallet), true, true);
	\end{lstlisting}
	
	\subsection{"Possible Solutions"}
	% Navigating to source code via Chrome debug api or open in another IDE
		%TODO: find command to navigate
		% It is easily possible to navigate to a line number in a file, if the actual file url (can difffer due to many factors) is known. For the reasons explained above, navigating to the instrumented code is not desirable. A not instrumentated version seems to exist in chromes source windows as dynamic script, but it is not actually  used at runtime. This approach would provide the user with syntax highlighting thorugh Chrome and other features like search with regular expressions. The user could also inspect the whole code of the application, not just the piece of code corresponding to a single node. The downside of this approach is that the user needs to leave the UI of CRI to access the source information. For a single node this is not an issue, but it is really cumbersome to inspected the source information of multiple nodes.
		% Con:
			% - missing highlighting of corresponding code, source code position information consisting of start and end character positions has to be searched by the user himself. The navigation can only scroll it into focuss. ###
			% - if navigating with chrome devtools: breakpoints will show but never trigger which could confuse the user
			% most features of Chrome debugger wont work and there is no way to indicate which ones do work to the user. E.g. direct evaluation code (except for pure code like a mathmatical formula since no variables actually contain a value), breakpoints and watches wont work.
			% if another IDE is used "Go to declaration" is probably availabe which provides scaleable query features not provided by a simple string search. Enterprise size applications may return to many results for a string query to be usefull.
	% Opening the code in a simple file viewer
		% Open the file in a popup or using an additional view e.g. a tab in the CRI to display the full code.
		% pro: 
			% full code can be provided - multiple files can be shown
			% it is possible to implement syntax highlighting based on context
			% it is possible, although cumbersome, to customize the view in any way - each observable could be marked in the source code and additional information could be displayed to the user. Reverse of what is implemented now -> abstract with code info, would be code with abstract info. But this would move the focus from the abstract to the code.
		% con: 
			% custom solution which takes tremendous effort to implement, because there is nothing available that fullfills every requirement and for a fully customizeable solution it would effectively be a lightweight IDE.
			% still requires the user to leave the abstract representation and loose foucs
			% cumbersome to examine a set of nodes that share a dependency or are directly related in the abstract graph but are not in close proximity in the JavaScript source code.
	% using a mirror
		% instead of instrumenting the source code used at runtime, use a copy of the website that is instrumented and mirror all interaction from the original to the instrumented version. This would enable the option to navigate to the real source code used at runtime when a node is selected for inspection, since the used code is no longer instrumented.
		% pro: 
			% this would enable all features of chrome to be used a runtime like normal breakpoints, eval in code, syntax highlighting, watches.
		% con: 
			% not easy to record and replay all interactions in realtime if at all - many interactions the user can do to a website are restricted to the acual user due to important security restrictions. E.g. context menu interactions or clipboard access is restricted. In addition some types of ui interactions like mouse movement or drag and drop are hard to record and replay rebustly enough while still keeping performance
			% the mirror needs to match exactly - same resolution due to media queries and other resolution dependent code. If some size calculation is done via JavaScript everything has to be calculated equally. This is nearly impossible to achieve precise enough due to rounding errors.
			% timing is the killing factor here. The replay on the mirror has to match exactly in regards to timing, if not the values of observables and results of calculations based on the system time will turn out differently. This issue might be solveable by replacing some APIs with custom copies that slows down the system enough to enable CRI to mirror the steps in the same time frame. E.g. a mousemove event fires multiple times in fixed intervals if the user moves the mouse - the mirrors observables that use mousemove would have to contain the exact same number of values at any given time to remove synchronicity issues for arbitrary applications.
			% access to Chrome API would have to be intercepted and directed to a fake API - otherwise calls with sideeffects will execute twice. Requests to e.g. WebAPIs might trigger abuse detection because they have to be executed in a very short period of time. This could be solved by intercepting everything that targets an outside element and just fetching the result instead of actually executing them twice, but this will change timing of calls if they are not forced to be synchronized between the mirror and the real application.
			% twice the resources needed
	% Source Code Tooltips
		% - use tooltip that opens when CTRL is hold down on node that displays a snippet of the original code that contains the code corresponding to a node with surrounding lines of code. Or use CTRL click to open the snippet.
		% details in "Implemented Solution"
		%TODO: make sure there are not duplicates in Implemented Solution.
		% Pro: - precise highlighting of corresponding code possible
			% - serves as additional details for nodes, can help identify a node that has no name
			% - helps the user to find and remember a node without a name between multiple uses of the extension by other means than the id. The id may have changed due to changes to the previously executed code.
			% - fast to open/close and without leaving the extensions UI
		% Con: - if the chain of functions is to large, not all relevant code can be shown and in general big chains are hard to read.
			% - no search or other code inspection tools available for the code snippet -> the user would have to use an external tool and the line number for that. No breakpoints, though there are not that useful in reactive programming anyway as described in #state of the art chapter.
			% - can not use existing syntax highlighting of chrome or an IDE. Implementing a own syntax highlighting would not be easy, because if just the small snippet is analysed all context relying highlighting will be lost. Basic keywords would be possible but with own implementation or third party library.
			% full code is not availabe for the user
			% the displayed code can not be examined with features like search - but they are short enough to be examined in a few seconds.
			
	\subsection{Implemented Solution - Source Code Tooltips}
	% display the origin  JS code of a node 
	% change tooltip to show the code if ctrl pressed while mouse enter or when already on element to speed up inspection of multiple nodes one after another
		% limited capabilities of used jalangi -> developed for a special demo, not in general (mentioned in state of the art)
		% jalangi extension via shallow copy
		% tipsy.js - switching out the tooltip with the function
		% link source to specific js file
		% for developers: find instrumented file - added sourcemap
	- when hovering above node press ctrl to view source code (canvas needs to have tabindex to be focusable)
	- nodes have faded border if they do not have source information. names nodes always have source information
	- bind special keypress event for hovered node to canvas
	- remove handlers when leaving
		% The class TooltipManager handles the creation and displaying of tooltips for all nodes in the Dependency Graph. It adds the UI events used to switch out the tooltips and requests the code needed to construct the Source Code Tooltips from the instrumentation script if the tooltip was not opened before in this step for this node.
	- add functional title for tipsy tooltips
	- Connection of abstract graph to code is not always helpful, because it takes/tuggs the user back to sequential/non-reactive thinking, but helps to understand nodes without other details or inexpressive names. Without this additional info the user is encouraged to split chained function calls and give each step a named variable, which not only is cumbersome but also may lead to diverting the focus from variables that should really have a name - also falls back to modifying the original source code to enable debugging like in do-debugging.
	
	% invokeFun intercepted for chained functions
	
	- the problem is to have the filename in the write function, because all instrumented files use the same jalangi sandbox.
	- the filenames in contrast to the original jalangi are not implemented in the minified non nodejs version taken from the demo page.
	- the only solution with minimal changes to the used jalangi-framework.js is to locally overwrite the W function in every instrumented file. Otherwise the whole instrumentation process would have to be customized.
	- the overwrite is done via shallow copying the J\$ object and replacing the W function with one that submits the filename as a fixed parameter to the analysis and calls the base.
	- to get additional info on observables previously not covered, the invokeFun was also extended with the filename and used to record source info. This can obviously not record names for additional nodes.
	- inline scripts are excluded from this because there might be many and that could lead to performance issues due to the shallow copying.
	If filename is not set, document domain is assumed for the filename.
	
	% we chose to give the user a visual clue if a node has a Source Code Tooltip so a user does not have to probe a nodes tooltip to see if it has one. Nodes without Source Code Tooltips have a faded border - we chose this, because having no Source Code Tooltip means the node does not provide any context information, named nodes always have one.
	% One could argue that the Location information could now be omitted from the normal tooltips, but it currently the only way for the user to see from which JS file the node originated. Source Code Tooltips do not show the filename.
	
	
		\subsubsection{Strengths and limitations of this approach} 
		% ui, syntax highlighting: syntax highlighting is hard for snippets because the context is missing
		% usefullness of code preview beyond a certain extend: 
			% Chained calls can be to long to display
			% it is nearly useless if the corresponding code is just a function that returns the observable because in contrast to an IDE the developer can not directly jump into the function to look at the acutal code.
			% best in chained calls because the developer can see which part of the chained call corresponds to the observable
			% if the chain is spread out e.g. because parts are assigned to variables the code corresponding to nodes that have a dependency can actually be many lines appart.
		% actual usage in general
		% what it provides and what it doesnt

\section{Rapidly updated Observables}
\label{sec:RapidlyUpdatedObservables}
% value changes often - generates a huge amount of steps
% reasons: timer, mouse, network
% steps can become unexpressive and hard to navigate
% most times the setup is the most important so solved by "pause" - the exception would be additonal observables created later in the execution like e.g. an observable created by a specific event that happens after a set period of time.
% hard to debug interactions that take place after the setup or during a "busy" phase
	
	\subsection{Difficulties and previous approach}
	% previous CRI could not handle well.
	% if the changes originate from anything other than user input - pausing recording is mandatory, 
	%  but continuing leaves gaps in change history that has no visual feedback to the user.
	% lag, getting stuck, crashing chrome due to increasing effort to handle coordination of async actions like message passing and storage access (read/write) => shorthand: request buildup
	% basic node exclusion was possible before, but very cumbersome and would exclude the node completely sometimes resuling in errors due to the node missing for dependent actions. A future implementation should only exclude value updates after the first. Should be changed in a way described in detail later.
	
	\subsection{Reworking the graph history}
	% what it is, what it contains: the graph history records every change to the graph as a new step. The previous implementation stored the whole graph for each step inside an array for simplicity. This means the required memory will increase proportianlly with the number of steps.
	% Performance improvements via paging and delta encoding: The idea to use paging was that the memory consumption would be fairly constant and not dependent on the number of steps. It still corresponded to the size of the graph, but since modern systems have a huge amount of RAM this increase would only affect the performance if thousands of nodes were in a graph which would not be possible for the user to comprehend anyway.
	% Paging was then advanced to Delta encoding because it better corresponded to the intention. The changes are the relevant data between steps - loggin the changes and their types actually provides more useful data and makes the changes easier to query because they do not have to be calculated (in the future the history query feature should be changed to use the graph instead of logging the changes itself). This enabled an easy and more robust way to detect the current change node and later edge - prior the current node was stored inside the node just as the css classes itself and was affected by search highlighting.
	% To reduce the computation cost to reconstruct a full graph for random stepping or stepping back in the history (not all changes can easily be reverted ----- full explanation here) an approach similar to "https://en.wikipedia.org/wiki/Video_compression_picture_types" without B-frames was implemented. The I frames are called BaseStages, P-frames DeltaStages that only encode the delta to the previous step. The size of the delta window can be configured in code and is currently 100 meaning each BaseStage will have 100 Detlas before a new basestage is created. code in history.js. The history also uses paging by loading several BaseStages at once in a specified window into a cache. This is important to cope with the user stepping forward and backwars repeatedly over a basestage threshold. To increase the cache size also reduces the distinct storage and load commands submitted to the Chrome storage api that is used to store any BaseStage currently not loaded into the cache.
	% paging -> to implement paging we used submitted the history parts that exceeded he cache to the local chrome storage which allows sizes of XX. If the history is cleared by the user or due to closing, opening a new CRI the storage is cleared. This will cause issues with multiple instances of CRI running at once, but unless both can use the same list of instrumented files (also stored in the chrome storage) this wont work anyway [maybe leave out]. When a stage is not in the cache, CRI will load it from the local storage and its surounding blocks into the cache. The requested step will be in the middle of the cache, if possible, to prevent the need to immediately load another stage if the user clicks next or previous.  In addition loading data in batches is normally faster than one by one, because it leaves optimization possiblilties to the used API.
	% delta encoding -> If a new delta stage is added or requested that is in the forward direction (without crossing over the base stage boundries) all changes can be directly applied to the current stage. If however the direction is backwards, the new graph is constructed by clearing the graph, loading the base stage and then appliying all deltas up to the requested stage. It is the same logic if a random stage is requested that is not part of the current base stage. This means forward is always faster than random or backwards. As noted above the adding is crucial for the recording process and this approach that keeps this use case fast and simple benefits the recording process. On the other hand stepping back and random access can only be triggered by the user.
	% deltas will contain the full node or edge regardless of if it was a new one or an old one was updated as they were recorded. The deltas do not need to be calculated first. -- intention from above.
	% The class GraphManager handles drawing of the displayed graph in the UI and request the loading of a different stage from the history when necessary. It also implements the highlighting of the current node or edge.
	% The class History handles the actual data, caching and requesting loading of stages from the storage when necessary. It also manages when to switch to the next basestage instead of adding another delta stage.
	% The shared object stageStorage provides a OO interface that loads and stores stages by calling the key-value based chrome storage api. stageStorage also schedules request internally to ensure that requests are handled sequentially and in the correct order - stages finished saving before the loading operation is executed. For this reason the loading operation is async and uses a callback that is invoked when the loading is done. To achive this sync, stageStorage uses a queue, if an operation finished storing or loading it will invoke the next operation in the queue.
 	% -> the saving has to be very fast
	% Memory and CPU for one test case with exactly equal conditions.
	% point out that even this has limitations - see mario example
	
	
	\subsection{"Further work"}
	% before cri3 CPU profiler results
	
	% throttling and debounce UI updates greatly increased performance
	% evaluation of throttle time for Ui changes and reasoning to pick a certain value - compromise between detectable for human and node update speed that can be handled
	% Excluding a node -> limitation:
		% may need to cover many nodes before the ui values are mapped to readable values -> ignore all ancestors option 
		% currently nodes can be excluded via Id in the options page, but this is to cumbersome since the user has to leave the current context, they are specific to one application and should not be in general options.
		%- should be able to ignore nodes via r-click on node, even with an option to exclude all dependents/dependencies - that did not work because time. Ignoring a node completely will sometimes break the dependency graph. Excluded nodes should be created and only value updates beyond the first should be ignored.
	

\section{Dynamically created observables}
% nodes are generated extensively
% mostly from the same line of code e.g. a loop or created in the local context of a function that is called multiple times
% (local nodes are short living for specific purpose)
% nodes are not identifyable to the user -> cant make connection between similar behaving nodes that could be merged into one node
% -> in case of named nodes the name will appear for each iteration - CRI can not handle decent in History Query and Search yet.
% Userinterface limits - unexpressive nodes, limited canvas
% loosing track of the nodes that matter; in case of multiple loops that creat observables that depend on each other these dynamically created nodes may cause the graph to be reordered during any step one is added. 
% can not be excluded easily

	\subsection{Increased recording complexity}
	% exluding them would require some form of excluding by rule/filter
	% detection for such nodes would be needed to handle them specially. They could be merged into one pseudo node if all outgoing edges have the same target and ingoing edges have the same source. If possible, detect named and nodes with same source info aht are created inside a loop and merge them if the dependencies and dependents are the same. But their value will certainly differ so the values have to be displayed as an array - an option to separate a bundle would probably be useful. 
	% To cope with the special cases, high customization of recording needed so the customization needs to be persistent to be useful
	
\section{CRI - A growing project}
% previous work was strictly focused on the features but now growing project presents issues

	\subsection{Increasing velocity}
	% reorganizing file structure to match placement in chrome devtools vs other posibilities
		% prior to this work there were some files with the window object corresponding to contentscripts in the same directory as files with a window object corresponding to the extensions window.
	% need for more documentation, still far from being fully documented but x new comments
		%TODO introduce shorthands CRI2 and CRI3
		% Chrome Reactive Inspector version 3, after this thesis (CRI3): 271 single line, 52 multiline
		% Chrome Reactive Inspector version 2, version created by Pradeep Baradur as part of his thesis (CRI2): 231 single line, 32 multiline
		% just source of CRI was used to collect results - libraries directory and jalangi-framework excluded. WebStorm/search for // and /* inside the CRI BEta/ CRI directory - usage in comments feature.
		% includes TODOs - more in CRI3,  and commented code - more in CRI2
	% encapsulation and separation of concerns to help track and correct errors or build on existing code
		% closures: a closure prevents variables to be accessed from the outside and makes them effectively private - works because variabels are bound to a function context in javascript. In the example a self executing function is used that returns a function. It is also possible to use closure to create pseudo classes in JS that can be instantiated with "new". A self executing function that returns a constructor function. In CRI we used both in addition to self executing functions that return an object with several functions to realise "public" functions and mimicing the usual behavior of a namespace to not pollute the global namespace and document the correspondence of a public function to a specific feature throug the actual code. 
		
		\begin{lstlisting}[language=JavaScript, caption={Example of RxJS code.},label={lst:closure}]
			var add = (function () {
			var counter = 0;
			return function () {return counter += 1;}
			})();
		\end{lstlisting}
		
		% CRI3: 19 own js files (excluding jalangi + libraries dir) - 9 new classes
		% not in closure:
		% background-communication -> only script in background context
		% options.js - not needed so far
		% panel.js - not enough time, needs to be split further to achieve separation of concerns.  search and history query feature need to be extracted too. The file should ultimately only be responsible to instanciate the other classes and delegate work. In short of implementing a full MVC or MVVM at least each distinc feature should be in its own file to limit influence to the explicint interfaces.
		% panel-communication.js - no enough time, because the functions and variables are used by code in panel.js
		% CRI2: 8 own js files, no closures, background, devtools, content-script-end are empty
		
		% most other code metrics normally used in OO can not be easily used on JavaScript like cohesion and coupling because it is not type save (is duck typed) makes it hard to detect which variable contains what class at runtime - there can easily be multiple "classes" that get assigned to the same variable, even dynamically so that there is no way to provide consisten results.
	
	% only in appendix because this has 0 value for the reader, but is needed to proove the claim:
	% CRI3 has 3580 total lines of code including comments, brackets, empty lines, just the number of lines per js file; average of 188 lines
	% CRI2: has 2353 total lines, 294 average
	
	\subsection{Build process}
	% (short section)
	% suggested way to exclude files; source: https://bugs.chromium.org/p/chromium/issues/detail?id=314360#c10
	% build project	to exclude files from packed extension. like the key or other project files that may contain sensual data.
	% keep in javascript to present familiar environment and language
	% could be used to miniy the extension before deployment in the future

	
\section{Summary}

	



