\section{Advancing the User Interface}
% present Issue and Solution for each of these:

	\subsection{Reducing the cognitive load on the user}
	% - remove "error" color from normal workflow -> change color palette
	% - usage frequency of input elements -> Reset, Download and Pause/Resume Recording moved to menu.
	%- find node that has specific criteria -> removed unexpressive labels with no data to reduced text to read, to presenting more details and reference to "linking source" that will follow.
	% - detect difference between one step and the next (what changed?) -> node (already there) and edge highlighting
	
	\subsection{Additional changes to the User-Interface}
	% - starting on a new application or different part of the application -> auto reload after instrumented files have changed
	% - just examine the result -> button to hide query tools
	% - searching for problems -> detect odd behavior, history queries (already present, mention that this is the reason for not relocating)
	% - checking specific node (e.g. ater trying to fix a problem) -> find node or dependents (already there)
	
\section{Connecting abstract graph with Javascript code}
	% goal
	% Difficulties: Instrumented source code
	
	\subsection{"Possible Solutions"}
	% Navigating to Source via Chrome debug api
		% - Problem: instrumentated javascript is not readable, not instrumentated version seems to exist in chromes code storage as dynamic script, but should not correspond because the instumented version is loaded dynamically.
		% correspondence between line in code and actual used javascript file is not working
		% easily possible to navigate to a line number in a file, if the file url is known and the javascript actually exists.
	% Opening the code in a simple file viewer
		% just navigate to or display the original code even though it is not the file currently used (because the current one is instrumented)
		% pro: full code, user can use find and search via IDE or Chrome devtools
		% con: - User has to leave the extension UI to do it. 
			% - Really cumbersome if many nodes are to be inspected. 
			% - unprecise, just the line number is not precise for chained calls.
			% - if navigating with chrome devtools: breakpoints will show but never trigger which could confuse the user
	% using a mirror
		%- keep copy of website that is instrumented and mirror all interaction to it
		%--> navigate to real one when clicked
	% Source Previews
		% - use popup that opens when strg click on node with surrounding lines
		% - change tooltip to show the code if ctrl pressed while mouse enter or when already on element
		% Pro: - precise highlighting of corresponding code possible
			% - serves as additional details for nodes, can help identify a node that has no name
			% - helps the user to find and remember a node without a name between multiple uses of the extension by other means than the id. The id may have changed due to changes to the previously executed code.
			% - fast to open/close and without leaving the extensions UI
		% Con: - if the chain of functions is to large, not all relevant code can be shown and in general big chains are hard to read.
			% - no search or other code inspection tools available for the code snippet -> the user would have to use an external tool and the line number for that. No breakpoints, though there are not that useful in reactive programming anyway as described in #state of the art chapter.
			% - can not use existing syntax highlighting of chrome or an IDE. Implementing a own syntax highlighting would not be easy, because if just the small snippet is analysed all context relying highlighting will be lost. Basic keywords would be possible but with own implementation or third party library.
	
	\subsection{Implemented Solution - Source Information Tooltips}
		% limited capabilities of used jalangi -> developed for a special demo, not in general (mentioned in state of the art)
		% jalangi extension via shallow copy
		% tipsy.js - switching out the tooltip with the function
		% link source to specific js file
		% for developers: find instrumented file - added sourcemap
	- when hovering above node press ctrl to view source code (canvas needs to have tabindex to be focusable)
	- bind special keypress event for hovered node to canvas
	- remove handlers when leaving
	- add functional title for tipsy tooltips
	- Connection of abstract graph to code is not always helpful, because it takes/tuggs the user back to sequential/non-reactive thinking, but helps to understand nodes without other details or inexpressive names. Without this additional info the user is encouraged to split chained function calls and give each step a named variable, which not only is cumbersome but also may lead to diverting the focus from variables that should really have a name.
	
	- the problem is to have the filename in the write function, because all instrumented files use the same jalangi sandbox.
	- the filenames in contrast to the original jalangi are not implemented in the minified non nodejs version taken from the demo page.
	- the only solution with minimal changes to the used jalangi-framework.js is to locally overwrite the W function in every instrumented file.
	- the overwrite is done via shallow copying the J\$ object and replacing the W function.
	- to get additional info an observables previously not covered, the invokeFun was also extended with the filename and used to record source info. This can obviously not record names for additional nodes.
	- inline scripts are excluded from this because there might be many and that could lead to performance issues due to the shallow copying.
	If filename is not set, document domain is assumed for the filename.
	
	
		\subsubsection{Strengths and limitations of this approach} 
		% ui, syntax highlighting
		% usefullness of code preview beyond a certain extend
		% actual usage in general
		% what it provides and what it doesnt


\section{Rapidly updated Observables}
% value changes often - generates a huge amount of steps
% reasons: timer, mouse, network
% steps can become unexpressive and hard to navigate
% most times the setup is the most important so solved by "pause"
% hard to debug interactions that take place after the setup or during a "busy" phase
	
	\subsection{Difficulties and previous approach}
	% previous CRI could not handle well.
	% if the changes originate from anything other than user input - pausing recording is mandatory, 
	%  but continuing leaves gaps in change history that has no visual feedback to the user.
	% lag, getting stuck, crashing chrome due to increasing effort to handle coordination of async actions (async buildup)
	% basic node exclusion was possible before, but very cumbersome. Should be changed in a way described later
	
	\subsection{Reworking the graph history}
	% what it is, what it contains
	% Performance improvements via paging and delta encoding
	% -> the saving has to be very fast
	% Memory and CPU for one test case with exactly equal conditions.
	% point out that even this has limitations - see mario example
	
	\subsection{"Further work"}
	% before cri3 CPU profiler results
	% throttling and debounce UI updates greatly increased performance
	% evaluation of throttle time for Ui changes and reasoning to pick a certain value - compromise between detectable for human and node update speed that can be handled
	% Excluding a node -> limitation: may need to cover many nodes before the ui values are mapped to readable values -> ignore all ancestors option 
	%- should be able to ignore nodes via r-click on node, even with an option to exclude all dependents/dependencies - that did not work because time. 
	% reduce the number of steps by removing node info updates that are not value changes from the history. (only a few, but still) they dont need separate steps when extra info is added

\section{Dynamically created observables}
% nodes are generated extensively
% mostly from the same line of code e.g. a loop or created in the local context of a function that is called multiple times
% (local nodes are short living for specific purpose)
% nodes are not identifyable to the user -> cant make connection between similar behaving nodes that could be merged into one node
% Userinterface limits - unexpressive nodes, limited canvas
% loosing track of the nodes that matter
% can not be excluded easily

	\subsection{Increased recording complexity}
	% exluding them would require some form of excluding by rule/filter
	% detection for such nodes would be needed to handle them specially. They could be merged into one pseudo node if all outgoing edges have the same target and ingoing edges have the same source.
	% To cope with the special cases, high customization of recording needed so the customization needs to be persistent to be useful
	
\section{CRI - A growing project}
% previous work was strictly focused on the features but now growing project presents issues

	\subsection{Increasing velocity}
	% reorganizing file structure to match placement in chrome devtools vs other posibilities
	% need for more documentation, still far from being fully documented but x new comments
	% encapsulation to help track and correct errors or build on existing code
	
	\subsection{Code metrics for script languages}
	% why some are not suitable for js
	% instead: number of files, min max average number of lines and why this is not a definite improvement.
	% x new classes and files, 
	
	\subsection{Build process}
	% (short section)
	% build project	to exclude files from packed extension. like the key or other project files that may contain sensual data.
	% keep in javascript to present familiar environment and language
	
\section{Summary}

	



